{"version":3,"mappings":"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","names":["__vitePreload","Segmenter","_define_property","obj","key","value","CustomError","name","message","code","stack","Err_Cannot_find_a_running_iterator_with_given_ID","Err_Only_string_can_be_the_RPC_method_name","Err_Cannot_call_method_starts_with_rpc_dot_directly","Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options","Messages","makeHostedMessage","id","error","errors","DOMExceptionHeader","RecoverError","type","E","globalDOMException","e","removeStackHeader","isString","x","isBoolean","isFunction","isObject","params","ERROR","undefined$1","Promise_resolve","isArray","replayFunction","jsonrpc","Request","method","remoteStack","deleteUndefined","deleteFalsy","SuccessResponse","result","ErrorResponse","data","ErrorResponseParseError","mapper","ErrorResponseMapped","o","ErrorResponseInvalidRequest","ErrorResponseMethodNotFound","request","defaultErrorMapper","toString","ctor","isJSONRPCObject","_default","val","v","i","AsyncCallIgnoreResponse","AsyncCallNotify","AsyncCallBatch","generateRandomID","undefinedToTrue","normalizeLogOptions","log","beCalled","localError","remoteError","requestReplay","sendLocalStack","normalizeStrictOptions","strict","methodNotFound","unknownMessage","AsyncCall","thisSideImplementation","options","isThisSideImplementationPending","resolvedThisSideImplementationValue","rejectedThisSideImplementation","resolvedChannel","channelPromise","awaitThisSideImplementation","console_error","onChannelResolved","channel","isCallbackBasedChannel","rawMessageReceiver","rawMessageSender","_","deserialization","isEventBasedChannel","m","serializer","logKey","parameterStructures","preferLocalImplementation","idGenerator","mapError","logger","thenable","banMethodNotFound","banUnknownMessage","log_beCalled","log_localError","log_remoteError","log_pretty","log_requestReplay","log_sendLocalStack","console_log","console_debug","console_groupCollapsed","console_groupEnd","console_warn","requestContext","onRequest","makeErrorObject","frameworkStack","req_id","executor","args","promise","resolve","logArgs","replay","onResponse","errorMessage","remoteErrorStack","errorCode","errorType","detail","reject","localErrorStack","handleSingleMessage","res","reply","serialization","fstack","sendPayload","payload","removeQueueR","rejectsQueue","queue","ctx","r","call","notify","RPCInternalMethod","localImpl","param","getTrap","f","f2","methodContainer","instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","cursorRequestMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","unlisten","success","wrap","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","target","prop","receiver","replaceTraps","callback","wrapFunction","func","storeNames","unwrap","transformCachableValue","newValue","openDB","version","blocked","upgrade","blocking","terminated","openPromise","event","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","storeName","oldTraps","A","t","n","a","j","g","y","h","b","D","l","s","S","d","p","u","w","U","q","z","M","L","V","$","R","k","P","C","B","T","W"],"sources":["../../polyfill/intl-segmenter.ts","../../../../node_modules/.pnpm/async-call-rpc@6.3.1/node_modules/async-call-rpc/out/base.mjs","../../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/wrap-idb-value.js","../../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/index.js","../../../../node_modules/.pnpm/y-provider@0.10.0-canary.9_yjs@13.6.10/node_modules/y-provider/dist/index.js","../../../../node_modules/.pnpm/@toeverything+y-indexeddb@0.10.0-canary.9_yjs@13.6.10/node_modules/@toeverything/y-indexeddb/dist/index.js"],"sourcesContent":["if (Intl.Segmenter === undefined) {\n  void import('intl-segmenter-polyfill-rs').then(({ Segmenter }) => {\n    Object.defineProperty(Intl, 'Segmenter', {\n      value: Segmenter,\n      configurable: true,\n      writable: true,\n    });\n  });\n}\n","/// <reference types=\"./base.d.ts\" />\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass CustomError extends Error {\n    constructor(name, message, code, stack){\n        super(message);\n        _define_property(this, \"name\", void 0);\n        _define_property(this, \"code\", void 0);\n        _define_property(this, \"stack\", void 0);\n        this.name = name;\n        this.code = code;\n        this.stack = stack;\n    }\n}\nconst Err_Cannot_find_a_running_iterator_with_given_ID = {};\nconst Err_Only_string_can_be_the_RPC_method_name = {};\nconst Err_Cannot_call_method_starts_with_rpc_dot_directly = {};\nconst Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options = {};\nconst Messages = [\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options\n];\n// https://github.com/Jack-Works/async-call-rpc/wiki/Error-messages\nconst makeHostedMessage = (id, error)=>{\n    const n = Messages.indexOf(id);\n    error.message += `Error ${n}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#` + n;\n    return error;\n};\n// ! side effect\n/** These Error is defined in ECMAScript spec */ const errors = {\n    // @ts-expect-error\n    __proto__: null,\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError\n};\nconst DOMExceptionHeader = 'DOMException:';\n/**\n * AsyncCall support somehow transfer ECMAScript Error\n */ const RecoverError = (type, message, code, stack)=>{\n    try {\n        const E = globalDOMException();\n        if (type.startsWith(DOMExceptionHeader) && E) {\n            const name = type.slice(DOMExceptionHeader.length);\n            return new E(message, name);\n        } else if (type in errors) {\n            const e = new errors[type](message);\n            e.stack = stack;\n            // @ts-expect-error\n            e.code = code;\n            return e;\n        } else {\n            return new CustomError(type, message, code, stack);\n        }\n    } catch (e) {\n        return new Error(`E${code} ${type}: ${message}\\n${stack}`);\n    }\n};\nconst removeStackHeader = (stack)=>String(stack).replace(/^.+\\n.+\\n/, '');\n// ! side effect\nconst globalDOMException = ()=>{\n    try {\n        // @ts-expect-error\n        return DOMException;\n    } catch (e) {}\n};\n\nconst isString = (x)=>typeof x === 'string';\nconst isBoolean = (x)=>typeof x === 'boolean';\nconst isFunction = (x)=>typeof x === 'function';\nconst isObject = (params)=>typeof params === 'object' && params !== null;\nconst ERROR = 'Error';\nconst undefined$1 = void 0;\nconst Promise_resolve = (x)=>Promise.resolve(x);\nconst isArray = Array.isArray;\nconst replayFunction = ()=>'() => replay()';\n\nconst jsonrpc = '2.0';\nconst Request = (id, method, params, remoteStack)=>{\n    const x = {\n        jsonrpc,\n        id,\n        method,\n        params,\n        remoteStack\n    };\n    deleteUndefined(x, 'id');\n    deleteFalsy(x, 'remoteStack');\n    return x;\n};\nconst SuccessResponse = (id, result)=>{\n    const x = {\n        jsonrpc,\n        id,\n        result\n    };\n    deleteUndefined(x, 'id');\n    return x;\n};\nconst ErrorResponse = (id, code, message, data)=>{\n    if (id === undefined$1) id = null;\n    code = Math.floor(code);\n    if (Number.isNaN(code)) code = -1;\n    const x = {\n        jsonrpc,\n        id,\n        error: {\n            code,\n            message,\n            data\n        }\n    };\n    deleteUndefined(x.error, 'data');\n    return x;\n};\n// Pre defined error in section 5.1\n// ! side effect\nconst ErrorResponseParseError = (e, mapper)=>{\n    const obj = ErrorResponseMapped({}, e, mapper);\n    const o = obj.error;\n    o.code = -32700;\n    o.message = 'Parse error';\n    return obj;\n};\n// Not using.\n// InvalidParams -32602 'Invalid params'\n// InternalError -32603 'Internal error'\nconst ErrorResponseInvalidRequest = (id)=>ErrorResponse(id, -32600, 'Invalid Request');\nconst ErrorResponseMethodNotFound = (id)=>ErrorResponse(id, -32601, 'Method not found');\nconst ErrorResponseMapped = (request, e, mapper)=>{\n    const { id  } = request;\n    const { code , message , data  } = mapper(e, request);\n    return ErrorResponse(id, code, message, data);\n};\nconst defaultErrorMapper = (stack = '', code = -1)=>(e)=>{\n        let message = toString('', ()=>e.message);\n        let type = toString(ERROR, (ctor = e.constructor)=>isFunction(ctor) && ctor.name);\n        const E = globalDOMException();\n        if (E && e instanceof E) type = DOMExceptionHeader + e.name;\n        if (isString(e) || typeof e === 'number' || isBoolean(e) || typeof e === 'bigint') {\n            type = ERROR;\n            message = String(e);\n        }\n        const data = stack ? {\n            stack,\n            type\n        } : {\n            type\n        };\n        return {\n            code,\n            message,\n            data\n        };\n    };\nconst isJSONRPCObject = (data)=>{\n    if (!isObject(data)) return false;\n    if (!('jsonrpc' in data)) return false;\n    if (data.jsonrpc !== jsonrpc) return false;\n    if ('params' in data) {\n        const params = data.params;\n        if (!isArray(params) && !isObject(params)) return false;\n    }\n    return true;\n};\nconst toString = (_default, val)=>{\n    try {\n        const v = val();\n        if (v === undefined$1) return _default;\n        return String(v);\n    } catch (e) {\n        return _default;\n    }\n};\nconst deleteUndefined = (x, key)=>{\n    if (x[key] === undefined$1) delete x[key];\n};\nconst deleteFalsy = (x, key)=>{\n    if (!x[key]) delete x[key];\n};\n\n//#region Serialization\n/**\n * Serialization implementation that do nothing\n * @remarks {@link Serialization}\n * @public\n * @deprecated Will be removed in next major version\n */ const NoSerialization = {\n    serialization (from) {\n        return from;\n    },\n    deserialization (serialized) {\n        return serialized;\n    }\n};\n/**\n * Create a serialization by JSON.parse/stringify\n *\n * @param replacerAndReceiver - Replacer and receiver of JSON.parse/stringify\n * @param space - Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n * @param undefinedKeepingBehavior - How to keep \"undefined\" in result of SuccessResponse?\n *\n * If it is not handled properly, JSON.stringify will emit an invalid JSON RPC object.\n *\n * Options:\n * - `\"null\"`(**default**): convert it to null.\n * - `\"keep\"`: try to keep it by additional property \"undef\".\n * - `false`: Don't keep it, let it break.\n * @remarks {@link Serialization}\n * @public\n */ const JSONSerialization = (replacerAndReceiver = [\n    undefined$1,\n    undefined$1\n], space, undefinedKeepingBehavior = 'null')=>({\n        serialization (from) {\n            if (undefinedKeepingBehavior && isObject(from) && 'result' in from && from.result === undefined$1) {\n                const alt = {\n                    ...from\n                };\n                alt.result = null;\n                if (undefinedKeepingBehavior === 'keep') alt.undef = true;\n                from = alt;\n            }\n            return JSON.stringify(from, replacerAndReceiver[0], space);\n        },\n        deserialization (serialized) {\n            const result = JSON.parse(serialized, replacerAndReceiver[1]);\n            if (isObject(result) && 'result' in result && result.result === null && 'undef' in result && result.undef === true) {\n                result.result = undefined$1;\n                delete result.undef;\n            }\n            return result;\n        }\n    } //#endregion\n    );\n\nconst i = 'AsyncCall/';\n// ! side effect\nconst AsyncCallIgnoreResponse = Symbol.for(i + 'ignored');\nconst AsyncCallNotify = Symbol.for(i + 'notify');\nconst AsyncCallBatch = Symbol.for(i + 'batch');\n\n/**\n * Wrap the AsyncCall instance to send notification.\n * @param instanceOrFnOnInstance - The AsyncCall instance or function on the AsyncCall instance\n * @example\n * const notifyOnly = notify(AsyncCall(...))\n * @public\n */ function notify(instanceOrFnOnInstance) {\n    if (isFunction(instanceOrFnOnInstance)) return instanceOrFnOnInstance[AsyncCallNotify];\n    return new Proxy(instanceOrFnOnInstance, {\n        get: notifyTrap\n    });\n}\nconst notifyTrap = (target, p)=>{\n    return target[p][AsyncCallNotify];\n};\n\n/**\n * Wrap the AsyncCall instance to use batch call.\n * @param asyncCallInstance - The AsyncCall instance\n * @example\n * const [batched, send, drop] = batch(AsyncCall(...))\n * batched.call1() // pending\n * batched.call2() // pending\n * send() // send all pending requests\n * drop() // drop all pending requests\n * @returns It will return a tuple.\n *\n * The first item is the batched version of AsyncCall instance passed in.\n *\n * The second item is a function to send all pending requests.\n *\n * The third item is a function to drop and reject all pending requests.\n * @public\n */ function batch(asyncCallInstance) {\n    const queue = [];\n    const getTrap = new Proxy({}, {\n        get (_, p) {\n            // @ts-expect-error\n            const f = (...args)=>asyncCallInstance[AsyncCallBatch](queue, p, ...args);\n            // @ts-expect-error\n            f[AsyncCallNotify] = (...args)=>// @ts-expect-error\n                asyncCallInstance[AsyncCallBatch][AsyncCallNotify](queue, p, ...args);\n            // @ts-expect-error\n            f[AsyncCallNotify][AsyncCallNotify] = f[AsyncCallNotify];\n            isString(p) && Object.defineProperty(methodContainer, p, {\n                value: f,\n                configurable: true\n            });\n            return f;\n        }\n    });\n    const methodContainer = {\n        __proto__: getTrap\n    };\n    return [\n        new Proxy(methodContainer, {\n            getPrototypeOf: ()=>null,\n            setPrototypeOf: (_, value)=>value === null\n        }),\n        ()=>{\n            queue.length && queue.r[0]();\n            queue.length = 0;\n        },\n        (error = new Error('Aborted'))=>{\n            queue.length && queue.r[1](error);\n            queue.length = 0;\n        }\n    ];\n}\n\nconst generateRandomID = ()=>Math.random().toString(36).slice(2);\n\nconst undefinedToTrue = (x)=>x === void 0 ? true : x;\nconst normalizeLogOptions = (log)=>{\n    if (log === 'all') return [\n        true,\n        true,\n        true,\n        true,\n        true,\n        true\n    ];\n    if (!isBoolean(log)) {\n        const { beCalled , localError , remoteError , type , requestReplay , sendLocalStack  } = log;\n        return [\n            undefinedToTrue(beCalled),\n            undefinedToTrue(localError),\n            undefinedToTrue(remoteError),\n            type !== 'basic',\n            requestReplay,\n            sendLocalStack\n        ];\n    }\n    if (log) return [\n        true,\n        true,\n        true,\n        true\n    ];\n    return [];\n};\nconst normalizeStrictOptions = (strict)=>{\n    if (!isBoolean(strict)) {\n        const { methodNotFound , unknownMessage  } = strict;\n        return [\n            methodNotFound,\n            unknownMessage\n        ];\n    }\n    return [\n        strict,\n        strict\n    ];\n};\n\n/**\n * Create a RPC server & client.\n *\n * @remarks\n * See {@link AsyncCallOptions}\n *\n * thisSideImplementation can be a Promise so you can write:\n *\n * ```ts\n * export const service = AsyncCall(typeof window === 'object' ? {} : import('./backend/service.js'), {})\n * ```\n *\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server. Can be a Promise.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, it will be converted to the async version.\n * @returns Same as the `OtherSideImplementedFunctions` type parameter, but every function in that interface becomes async and non-function value is removed. Method called \"then\" are also removed.\n * @public\n */ function AsyncCall(thisSideImplementation, options) {\n    let isThisSideImplementationPending = true;\n    let resolvedThisSideImplementationValue;\n    let rejectedThisSideImplementation;\n    let resolvedChannel;\n    let channelPromise;\n    // This promise should never fail\n    const awaitThisSideImplementation = async ()=>{\n        try {\n            resolvedThisSideImplementationValue = await thisSideImplementation;\n        } catch (e) {\n            rejectedThisSideImplementation = e;\n            console_error('AsyncCall failed to start', e);\n        } finally{\n            isThisSideImplementationPending = false;\n        }\n    };\n    const onChannelResolved = (channel)=>{\n        resolvedChannel = channel;\n        if (isCallbackBasedChannel(channel)) {\n            channel.setup((data)=>rawMessageReceiver(data).then(rawMessageSender), (data)=>{\n                const _ = deserialization(data);\n                if (isJSONRPCObject(_)) return true;\n                return Promise_resolve(_).then(isJSONRPCObject);\n            });\n        }\n        if (isEventBasedChannel(channel)) {\n            const m = channel;\n            m.on && m.on((_)=>rawMessageReceiver(_).then(rawMessageSender).then((x)=>x && m.send(x)));\n        }\n        return channel;\n    };\n    const { serializer , key: logKey = 'rpc' , strict =true , log =true , parameterStructures ='by-position' , preferLocalImplementation =false , idGenerator =generateRandomID , mapError , logger , channel , thenable  } = options;\n    if (thisSideImplementation instanceof Promise) awaitThisSideImplementation();\n    else {\n        resolvedThisSideImplementationValue = thisSideImplementation;\n        isThisSideImplementationPending = false;\n    }\n    const [banMethodNotFound, banUnknownMessage] = normalizeStrictOptions(strict);\n    const [log_beCalled, log_localError, log_remoteError, log_pretty, log_requestReplay, log_sendLocalStack] = normalizeLogOptions(log);\n    const { log: console_log , error: console_error = console_log , debug: console_debug = console_log , groupCollapsed: console_groupCollapsed = console_log , groupEnd: console_groupEnd = console_log , warn: console_warn = console_log  } = logger || console;\n    const requestContext = new Map();\n    const onRequest = async (data)=>{\n        if (isThisSideImplementationPending) await awaitThisSideImplementation();\n        else {\n            // not pending\n            if (rejectedThisSideImplementation) return makeErrorObject(rejectedThisSideImplementation, '', data);\n        }\n        let frameworkStack = '';\n        try {\n            const { params , method , id: req_id , remoteStack  } = data;\n            // ? We're mapping any method starts with 'rpc.' to a Symbol.for\n            const key = method.startsWith('rpc.') ? Symbol.for(method) : method;\n            const executor = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[key];\n            if (!isFunction(executor)) {\n                if (!banMethodNotFound) {\n                    if (log_localError) console_debug('Missing method', key, data);\n                    return;\n                } else return ErrorResponseMethodNotFound(req_id);\n            }\n            const args = isArray(params) ? params : [\n                params\n            ];\n            frameworkStack = removeStackHeader(new Error().stack);\n            const promise = new Promise((resolve)=>resolve(executor.apply(resolvedThisSideImplementationValue, args)));\n            if (log_beCalled) {\n                if (log_pretty) {\n                    const logArgs = [\n                        `${logKey}.%c${method}%c(${args.map(()=>'%o').join(', ')}%c)\\n%o %c@${req_id}`,\n                        'color: #d2c057',\n                        '',\n                        ...args,\n                        '',\n                        promise,\n                        'color: gray; font-style: italic;'\n                    ];\n                    if (log_requestReplay) {\n                        // This function will be logged to the console so it must be 1 line\n                        // prettier-ignore\n                        const replay = ()=>{\n                            debugger;\n                            return executor.apply(resolvedThisSideImplementationValue, args);\n                        };\n                        replay.toString = replayFunction;\n                        logArgs.push(replay);\n                    }\n                    if (remoteStack) {\n                        console_groupCollapsed(...logArgs);\n                        console_log(remoteStack);\n                        console_groupEnd();\n                    } else console_log(...logArgs);\n                } else console_log(`${logKey}.${method}(${[\n                    ...args\n                ].toString()}) @${req_id}`);\n            }\n            const result = await promise;\n            if (result === AsyncCallIgnoreResponse) return;\n            return SuccessResponse(req_id, result);\n        } catch (e) {\n            return makeErrorObject(e, frameworkStack, data);\n        }\n    };\n    const onResponse = async (data)=>{\n        let errorMessage = '', remoteErrorStack = '', errorCode = 0, errorType = ERROR;\n        if ('error' in data) {\n            const e = data.error;\n            errorMessage = e.message;\n            errorCode = e.code;\n            const detail = e.data;\n            if (isObject(detail) && 'stack' in detail && isString(detail.stack)) remoteErrorStack = detail.stack;\n            else remoteErrorStack = '<remote stack not available>';\n            if (isObject(detail) && 'type' in detail && isString(detail.type)) errorType = detail.type;\n            else errorType = ERROR;\n            if (log_remoteError) log_pretty ? console_error(`${errorType}: ${errorMessage}(${errorCode}) %c@${data.id}\\n%c${remoteErrorStack}`, 'color: gray', '') : console_error(`${errorType}: ${errorMessage}(${errorCode}) @${data.id}\\n${remoteErrorStack}`);\n        }\n        const { id  } = data;\n        if (id === null || id === undefined$1 || !requestContext.has(id)) return;\n        const [resolve, reject, localErrorStack = ''] = requestContext.get(id);\n        requestContext.delete(id);\n        if ('error' in data) {\n            reject(RecoverError(errorType, errorMessage, errorCode, // ? We use \\u0430 which looks like \"a\" to prevent browser think \"at AsyncCall\" is a real stack\n            remoteErrorStack + '\\n    \\u0430t AsyncCall (rpc) \\n' + localErrorStack));\n        } else {\n            resolve(data.result);\n        }\n        return;\n    };\n    const rawMessageReceiver = async (_)=>{\n        let data;\n        let result = undefined$1;\n        try {\n            data = await deserialization(_);\n            if (isJSONRPCObject(data)) {\n                return result = await handleSingleMessage(data);\n            } else if (isArray(data) && data.every(isJSONRPCObject) && data.length !== 0) {\n                return Promise.all(data.map(handleSingleMessage));\n            } else {\n                if (banUnknownMessage) {\n                    let id = data.id;\n                    if (id === undefined$1) id = null;\n                    return ErrorResponseInvalidRequest(id);\n                } else {\n                    // ? Ignore this message. The message channel maybe also used to transfer other message too.\n                    return undefined$1;\n                }\n            }\n        } catch (e) {\n            if (log_localError) console_error(e, data, result);\n            // todo: should check before access e.stack\n            return ErrorResponseParseError(e, mapError || defaultErrorMapper(e && e.stack));\n        }\n    };\n    const rawMessageSender = async (res)=>{\n        if (!res) return;\n        if (isArray(res)) {\n            const reply = res.filter((x)=>x && 'id' in x);\n            if (reply.length === 0) return;\n            return serialization(reply);\n        } else {\n            return serialization(res);\n        }\n    };\n    const serialization = serializer ? (x)=>serializer.serialization(x) : Object;\n    const deserialization = serializer ? (x)=>serializer.deserialization(x) : Object;\n    if (channel instanceof Promise) channelPromise = channel.then(onChannelResolved);\n    else onChannelResolved(channel);\n    const makeErrorObject = (e, frameworkStack, data)=>{\n        if (isObject(e) && 'stack' in e) e.stack = frameworkStack.split('\\n').reduce((stack, fstack)=>stack.replace(fstack + '\\n', ''), '' + e.stack);\n        if (log_localError) console_error(e);\n        return ErrorResponseMapped(data, e, mapError || defaultErrorMapper(log_sendLocalStack ? e.stack : undefined$1));\n    };\n    const sendPayload = async (payload, removeQueueR = false)=>{\n        if (removeQueueR) payload = [\n            ...payload\n        ];\n        const data = await serialization(payload);\n        return (resolvedChannel || await channelPromise).send(data);\n    };\n    const rejectsQueue = (queue, error)=>{\n        for (const x of queue){\n            if ('id' in x) {\n                const ctx = requestContext.get(x.id);\n                ctx && ctx[1](error);\n            }\n        }\n    };\n    const handleSingleMessage = async (data)=>{\n        if ('method' in data) {\n            const r = onRequest(data);\n            if ('id' in data) return r;\n            try {\n                await r;\n            } catch (e) {}\n            return undefined$1 // Does not care about return result for notifications\n            ;\n        }\n        return onResponse(data);\n    };\n    const call = (method, args, stack, notify = false)=>{\n        return new Promise((resolve, reject)=>{\n            let queue = undefined$1;\n            if (method === AsyncCallBatch) {\n                queue = args.shift();\n                method = args.shift();\n            }\n            if (typeof method === 'symbol') {\n                const RPCInternalMethod = Symbol.keyFor(method) || method.description;\n                if (RPCInternalMethod) {\n                    if (RPCInternalMethod.startsWith('rpc.')) method = RPCInternalMethod;\n                    else throw new TypeError('Not start with rpc.');\n                }\n            } else if (method.startsWith('rpc.')) {\n                throw makeHostedMessage(Err_Cannot_call_method_starts_with_rpc_dot_directly, new TypeError());\n            }\n            if (preferLocalImplementation && !isThisSideImplementationPending && isString(method)) {\n                const localImpl = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[method];\n                if (isFunction(localImpl)) return resolve(localImpl(...args));\n            }\n            const id = idGenerator();\n            stack = removeStackHeader(stack);\n            const param = parameterStructures === 'by-name' && args.length === 1 && isObject(args[0]) ? args[0] : args;\n            const request = Request(notify ? undefined$1 : id, method, param, log_sendLocalStack ? stack : undefined$1);\n            if (queue) {\n                queue.push(request);\n                if (!queue.r) queue.r = [\n                    ()=>sendPayload(queue, true),\n                    (e)=>rejectsQueue(queue, e)\n                ];\n            } else sendPayload(request).catch(reject);\n            if (notify) return resolve();\n            requestContext.set(id, [\n                resolve,\n                reject,\n                stack\n            ]);\n        });\n    };\n    const getTrap = (_, method)=>{\n        const f = {\n            // This function will be logged to the console so it must be 1 line\n            [method]: (..._)=>call(method, _, new Error().stack)\n        }[method];\n        const f2 = {\n            [method]: (..._)=>call(method, _, new Error().stack, true)\n        }[method];\n        // @ts-expect-error\n        f[AsyncCallNotify] = f2[AsyncCallNotify] = f2;\n        isString(method) && Object.defineProperty(methodContainer, method, {\n            value: f,\n            configurable: true\n        });\n        return f;\n    };\n    const methodContainer = {\n        __proto__: new Proxy({}, {\n            get: getTrap\n        })\n    };\n    if (thenable === false) methodContainer.then = undefined$1;\n    else if (thenable === undefined$1) {\n        Object.defineProperty(methodContainer, 'then', {\n            configurable: true,\n            get () {\n                console_warn(makeHostedMessage(Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options, new TypeError('RPC used as Promise: ')));\n            }\n        });\n    }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: ()=>null,\n        setPrototypeOf: (_, value)=>value === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor (_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            ;\n            return Object.getOwnPropertyDescriptor(methodContainer, method);\n        }\n    });\n}\nconst isEventBasedChannel = (x)=>'send' in x && isFunction(x.send);\nconst isCallbackBasedChannel = (x)=>'setup' in x && isFunction(x.setup);\n\nexport { AsyncCall, JSONSerialization, NoSerialization, batch, notify };\n//# sourceMappingURL=base.mjs.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { applyUpdate as m, encodeStateAsUpdate as q, encodeStateVector as z } from \"yjs\";\nasync function I(t, n) {\n  const r = async (a) => {\n    const o = await n.queryDocState(a.guid);\n    o && m(a, o.missing, \"sync-doc-from-datasource\"), await Promise.all(\n      [...a.subdocs].map(async (f) => {\n        await r(f);\n      })\n    );\n  };\n  await r(t);\n}\nasync function O(t, n) {\n  const r = async (a) => {\n    await n.sendDocUpdate(a.guid, q(a)), await Promise.all(\n      [...a.subdocs].map(async (o) => {\n        await r(o);\n      })\n    );\n  };\n  await r(t);\n}\nasync function W(t, n, r) {\n  const a = t();\n  await Promise.all(\n    a.map((o) => r.queryDocState(o).then(async (f) => {\n      const g = await (async () => f ? n.queryDocState(o, {\n        stateVector: f.state\n      }) : n.queryDocState(o))();\n      if (g) {\n        const y = g.missing;\n        if (y.length === 2 && y[0] === 0 && y[1] === 0)\n          return;\n        await r.sendDocUpdate(o, g.missing);\n      }\n    }))\n  );\n}\nfunction A(t, n = \"val does not exist\") {\n  if (t == null)\n    throw n instanceof Error ? n : new Error(n);\n}\nfunction x(t, n) {\n  if (t.guid === n)\n    return t;\n  for (const r of t.subdocs) {\n    const a = x(r, n);\n    if (a)\n      return a;\n  }\n}\nconst j = (t, n, r = {}) => {\n  let a = !1;\n  const o = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set();\n  let y = null;\n  const { origin: h = \"lazy-provider\" } = r;\n  let b = {\n    type: \"idle\"\n  }, D = 0;\n  const v = /* @__PURE__ */ new Set(), l = (e) => {\n    e.type === \"syncing\" ? D++ : (e.type === \"synced\" || e.type === \"error\") && D--, D < 0 && console.error(\n      \"syncingStatus < 0, this should not happen\",\n      r.origin\n    ), D === 0 && (b = e), e.type !== \"synced\" && (b = e), D === 0 && (a ? b = {\n      type: \"synced\"\n    } : b = {\n      type: \"idle\"\n    }), v.forEach((s) => s());\n  };\n  async function S(e) {\n    const s = e.guid;\n    {\n      const c = s.startsWith(\"space:\") ? s.slice(6) : s, d = `${t.guid}:space:${c}`, p = `space:${c}`, u = await n.queryDocState(d), w = await n.queryDocState(p);\n      let U = !1;\n      u && u.missing.length !== 2 && u.missing[0] !== 0 && u.missing[1] !== 0 && (m(e, u.missing, h), U = !0), w && w.missing.length !== 2 && w.missing[0] !== 0 && w.missing[1] !== 0 && (m(e, w.missing, h), U = !0), U && await n.sendDocUpdate(\n        s,\n        q(\n          e,\n          u ? u.state : w ? w.state : void 0\n        )\n      );\n    }\n    if (!a)\n      return;\n    l({\n      type: \"syncing\"\n    });\n    const i = await n.queryDocState(s, {\n      stateVector: z(e)\n    }).then((c) => (l({\n      type: \"synced\"\n    }), c)).catch((c) => {\n      throw l({\n        type: \"error\",\n        error: c\n      }), c;\n    });\n    o.set(s, []), i && m(e, i.missing, h), a && (await n.sendDocUpdate(\n      s,\n      q(e, i ? i.state : void 0)\n    ), e.emit(\"sync\", []));\n  }\n  function M(e) {\n    const s = /* @__PURE__ */ new Set();\n    f.set(e.guid, s);\n    const i = async (d, p) => {\n      h !== p && (l({\n        type: \"syncing\"\n      }), n.sendDocUpdate(e.guid, d).then(() => {\n        l({\n          type: \"synced\"\n        });\n      }).catch((u) => {\n        l({\n          type: \"error\",\n          error: u\n        }), console.error(u);\n      }));\n    }, c = (d) => {\n      d.loaded.forEach((p) => {\n        E(p).catch(console.error);\n      }), d.removed.forEach((p) => {\n        L(p);\n      });\n    };\n    e.on(\"update\", i), e.on(\"subdocs\", c), s.add(() => {\n      e.off(\"update\", i), e.off(\"subdocs\", c);\n    });\n  }\n  function V() {\n    var s;\n    A(y, \"abortController should be defined\");\n    const e = (s = n.onDocUpdate) == null ? void 0 : s.call(n, (i, c) => {\n      var p;\n      l({\n        type: \"syncing\"\n      });\n      const d = x(t, i);\n      d ? (m(d, c, h), o.has(i) && ((p = o.get(i)) == null || p.forEach((u) => m(d, u, h)), o.delete(i))) : (console.warn(\"doc not found\", i), o.set(i, (o.get(i) ?? []).concat(c))), l({\n        type: \"synced\"\n      });\n    });\n    y.signal.addEventListener(\"abort\", () => {\n      e == null || e();\n    });\n  }\n  async function E(e) {\n    g.has(e.guid) || (g.add(e.guid), M(e), await S(e), await Promise.all(\n      [...e.subdocs].filter((s) => s.shouldLoad).map((s) => E(s))\n    ));\n  }\n  function L(e) {\n    g.delete(e.guid);\n    const s = f.get(e.guid);\n    s && (s.forEach((i) => i()), f.delete(e.guid)), e.subdocs.forEach(L);\n  }\n  function $() {\n    f.forEach((e) => {\n      e.forEach((s) => s());\n    }), f.clear(), g.clear();\n  }\n  function R() {\n    a = !0, y = new AbortController(), l({\n      type: \"syncing\"\n    }), E(t).then(() => {\n      l({\n        type: \"synced\"\n      });\n    }).catch((e) => {\n      l({\n        type: \"error\",\n        error: e\n      }), console.error(e);\n    }), V();\n  }\n  async function k() {\n    a = !1, $(), A(y, \"abortController should be defined\"), y.abort(), y = null;\n  }\n  const P = async (e) => {\n    await S(e), await Promise.all(\n      [...e.subdocs.values()].map((s) => P(s))\n    );\n  };\n  return {\n    sync: async (e) => {\n      a = !0;\n      try {\n        e ? await S(t) : await P(t);\n      } finally {\n        a = !1;\n      }\n    },\n    get status() {\n      return b;\n    },\n    subscribeStatusChange(e) {\n      return v.add(e), () => {\n        v.delete(e);\n      };\n    },\n    get connected() {\n      return a;\n    },\n    passive: !0,\n    connect: R,\n    disconnect: k,\n    datasource: n\n  };\n};\nfunction F(t, n) {\n  if (t.guid === n)\n    return t;\n  for (const r of t.subdocs) {\n    const a = F(r, n);\n    if (a)\n      return a;\n  }\n}\nconst C = (t) => (t.preventDefault(), t.returnValue = \"Data is not saved. Are you sure you want to leave?\"), B = async (t) => {\n  window.addEventListener(\"beforeunload\", C, {\n    capture: !0\n  }), await t, window.removeEventListener(\"beforeunload\", C, {\n    capture: !0\n  });\n};\nexport {\n  j as createLazyProvider,\n  F as getDoc,\n  W as syncDataSource,\n  O as syncDataSourceFromDoc,\n  I as syncDocFromDataSource,\n  B as writeOperation\n};\n//# sourceMappingURL=index.js.map\n","import { openDB as p } from \"idb\";\nimport { Doc as A, applyUpdate as S, encodeStateAsUpdate as D, diffUpdate as U, encodeStateVectorFromUpdate as B, encodeStateVector as P, UndoManager as M } from \"yjs\";\nimport { writeOperation as C, createLazyProvider as V } from \"y-provider\";\nconst m = 1, l = \"affine-local\";\nfunction f(e) {\n  e.createObjectStore(\"workspace\", { keyPath: \"id\" }), e.createObjectStore(\"milestone\", { keyPath: \"id\" });\n}\nfunction E(e, n = \"val does not exist\") {\n  if (e == null)\n    throw n instanceof Error ? n : new Error(n);\n}\nlet y;\nfunction g(e) {\n  const n = new A();\n  return e.forEach((a) => {\n    S(n, a);\n  }), D(n);\n}\nasync function O(e) {\n  return new Promise((n) => {\n    const a = indexedDB.open(e);\n    let t = !0;\n    a.onsuccess = function() {\n      a.result.close(), t || indexedDB.deleteDatabase(e), n(t);\n    }, a.onupgradeneeded = function() {\n      t = !1;\n    };\n  });\n}\nasync function q(e, n, a = l) {\n  do\n    if (!y || localStorage.getItem(`${a}-migration`) !== \"true\") {\n      try {\n        y = await indexedDB.databases();\n      } catch {\n        if (await O(n)) {\n          await p(n, 1).then(async (t) => {\n            if (!t.objectStoreNames.contains(\"updates\"))\n              return;\n            const r = await t.transaction(\"updates\", \"readonly\").objectStore(\"updates\").getAll();\n            if (!Array.isArray(r) || !r.every((d) => d instanceof Uint8Array))\n              return;\n            const o = g(r), i = e.transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\");\n            await i.get(n) || (console.log(\"upgrading the database\"), await i.put({\n              id: n,\n              updates: [\n                {\n                  timestamp: Date.now(),\n                  update: o\n                }\n              ]\n            }));\n          });\n          break;\n        }\n      }\n      await Promise.all(\n        y && y.map((t) => {\n          if (t.name && t.version === 1) {\n            const c = t.name, r = t.version;\n            return p(c, r).then(\n              async (o) => {\n                if (!o.objectStoreNames.contains(\"updates\"))\n                  return;\n                const s = await o.transaction(\"updates\", \"readonly\").objectStore(\"updates\").getAll();\n                if (!Array.isArray(s) || !s.every((b) => b instanceof Uint8Array))\n                  return;\n                const d = g(s), u = e.transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\");\n                await u.get(c) || (console.log(\"upgrading the database\"), await u.put({\n                  id: c,\n                  updates: [\n                    {\n                      timestamp: Date.now(),\n                      update: d\n                    }\n                  ]\n                }));\n              }\n            );\n          }\n        })\n      ), localStorage.setItem(`${a}-migration`, \"true\");\n      break;\n    }\n  while (!1);\n}\nasync function F(e, n = l) {\n  const r = await (await p(n, m, {\n    upgrade: f\n  })).transaction(\"workspace\", \"readonly\").objectStore(\"workspace\").get(e);\n  return r ? g(r.updates.map(({ update: o }) => o)) : !1;\n}\nasync function N(e, n, a = l) {\n  await (await p(a, m, {\n    upgrade: f\n  })).transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\").put({\n    id: e,\n    updates: [\n      {\n        timestamp: Date.now(),\n        update: n\n      }\n    ]\n  });\n}\nasync function _(e, n, a = l) {\n  const r = (await p(a, m, {\n    upgrade: f\n  })).transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\"), o = await r.get(e);\n  o ? (o.updates.push({\n    timestamp: Date.now(),\n    update: n\n  }), await r.put(o)) : await r.put({\n    id: e,\n    updates: [\n      {\n        timestamp: Date.now(),\n        update: n\n      }\n    ]\n  });\n}\nlet v = 500;\nfunction z(e) {\n  v = e;\n}\nconst T = ({\n  dbName: e = l,\n  mergeCount: n\n}) => {\n  let a = null;\n  const t = async () => (a === null && (a = p(e, m, {\n    upgrade: f\n  })), a);\n  return {\n    ...{\n      queryDocState: async (r, o) => {\n        var i;\n        try {\n          const u = await (await t()).transaction(\"workspace\", \"readonly\").objectStore(\"workspace\").get(r);\n          if (!u)\n            return !1;\n          const { updates: w } = u, b = g(w.map(({ update: x }) => x));\n          return { missing: o != null && o.stateVector ? U(b, o == null ? void 0 : o.stateVector) : b, state: B(b) };\n        } catch (s) {\n          if (!((i = s.message) != null && i.includes(\"The database connection is closing.\")))\n            throw s;\n          return !1;\n        }\n      },\n      sendDocUpdate: async (r, o) => {\n        var i;\n        try {\n          const d = (await t()).transaction(\"workspace\", \"readwrite\").objectStore(\"workspace\"), { updates: u } = await d.get(r) ?? { updates: [] };\n          let w = [\n            ...u,\n            { timestamp: Date.now(), update: o }\n          ];\n          if (n && w.length >= n) {\n            const b = g(w.map(({ update: k }) => k));\n            w = [{ timestamp: Date.now(), update: b }];\n          }\n          await C(\n            d.put({\n              id: r,\n              updates: w\n            })\n          );\n        } catch (s) {\n          if (!((i = s.message) != null && i.includes(\"The database connection is closing.\")))\n            throw s;\n        }\n      }\n    },\n    disconnect: () => {\n      t().then((r) => r.close()).then(() => {\n        a = null;\n      }).catch(console.error);\n    },\n    cleanup: async () => {\n      await (await t()).clear(\"workspace\");\n    }\n  };\n}, W = (e, n = l) => {\n  const a = T({ dbName: n, mergeCount: v });\n  let t = null;\n  const c = {\n    get status() {\n      return E(t), t.status;\n    },\n    subscribeStatusChange(r) {\n      return E(t), t.subscribeStatusChange(r);\n    },\n    connect: () => {\n      c.connected && c.disconnect(), t = V(e, a, { origin: \"idb\" }), t.connect();\n    },\n    disconnect: () => {\n      a == null || a.disconnect(), t == null || t.disconnect(), t = null;\n    },\n    cleanup: async () => {\n      await (a == null ? void 0 : a.cleanup());\n    },\n    get connected() {\n      return (t == null ? void 0 : t.connected) || !1;\n    },\n    datasource: a\n  };\n  return c;\n}, h = \"snapshot-origin\", j = (e) => (e.preventDefault(), e.returnValue = \"Data is not saved. Are you sure you want to leave?\"), G = async (e) => {\n  window.addEventListener(\"beforeunload\", j, {\n    capture: !0\n  }), await e, window.removeEventListener(\"beforeunload\", j, {\n    capture: !0\n  });\n};\nfunction H(e, n, a) {\n  const t = new A();\n  S(t, n, h);\n  const c = P(e), r = P(t), o = D(\n    e,\n    r\n  ), i = new M(\n    [...t.share.keys()].map((d) => {\n      const u = a(d);\n      if (u === \"Text\")\n        return t.getText(d);\n      if (u === \"Map\")\n        return t.getMap(d);\n      if (u === \"Array\")\n        return t.getArray(d);\n      throw new Error(\"Unknown type\");\n    }),\n    {\n      trackedOrigins: /* @__PURE__ */ new Set([h])\n    }\n  );\n  S(t, o, h), i.undo();\n  const s = D(\n    t,\n    c\n  );\n  S(e, s, h);\n}\nclass J extends Error {\n  constructor() {\n    super(\"Early disconnect\");\n  }\n}\nclass K extends Error {\n  constructor() {\n    super(\"Cleanup when connecting\");\n  }\n}\nconst Q = async (e, n, a, t = l) => {\n  const o = (await p(t, m, {\n    upgrade: f\n  })).transaction(\"milestone\", \"readwrite\").objectStore(\"milestone\"), i = await o.get(\"id\"), s = D(n);\n  i ? (i.milestone[a] = s, await o.put(i)) : await o.put({\n    id: e,\n    milestone: {\n      [a]: s\n    }\n  });\n}, R = async (e, n = l) => {\n  const r = await (await p(n, m, {\n    upgrade: f\n  })).transaction(\"milestone\", \"readonly\").objectStore(\"milestone\").get(e);\n  return r ? r.milestone : null;\n};\nexport {\n  K as CleanupWhenConnectingError,\n  l as DEFAULT_DB_NAME,\n  J as EarlyDisconnectError,\n  T as createIndexedDBDatasource,\n  W as createIndexedDBProvider,\n  m as dbVersion,\n  F as downloadBinary,\n  R as getMilestones,\n  Q as markMilestone,\n  g as mergeUpdates,\n  N as overwriteBinary,\n  _ as pushBinary,\n  H as revertUpdate,\n  z as setMergeCount,\n  q as tryMigrate,\n  f as upgradeDB,\n  G as writeOperation\n};\n//# sourceMappingURL=index.js.map\n"],"file":"assets/index-ASJIUfW0.js"}